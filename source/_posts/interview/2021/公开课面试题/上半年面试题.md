# Webpack

看到了 1:19 的位置

## 1. Webpack 中的 Module 是什么?

模块, 指的是前端的模块系统

Webpack 支持 ESModule, CommonJS, AMD, Assets(img, font, video, audio, font)

1. ESM

```js
import { aa } from "./a.js";
export { aa };
```

package.json -> 可以显示地设置模块是什么 -> type: Module(强制 package.json 下的所有文件都使用 ESM) / type: CommonJS(强制使用 CommonJS 模块)

2. CommonJS

```js
require();
module.exports;
```

## 2. 所以 Webpack modules, 如何表达自己的依赖关系

1. ESM: import 语句
2. CommonJS: require 语句
3. AMD: define require
4. css/sass/less: @import

## 3. 我们常说的 chunk 和 bundle 的区别是什么? (mark mark mark 特别特别重要 !!!)

如果 chunk 和 bundle 你都说不清除, 那 webpack 这一块你是直接被 pass 了

1. chunk

chunk 是 webpack 打包过程中 Modules 的集合, 是 (打包过程中) 的概念

webpack 的打包是从一个模块开始, 入口模块引用其他模块，其他模块又引用其他模块 ...
webpack 通过引用关系逐个打包模块, 这些 module 就形成了一个 chunk.

如果有多个入口模块, 那可能会产出多个打包路径, 每条路径都会形成一个 chunk.

一定要记住 chunk 是打包过程中的概念 !!!

2. bundle

是我们最终输出的一个或者多个打包好的文件

3. chunk 和 bundle 的关系和区别 ?

一句话总结: chunk 是过程, bundle 是结果.

(ps: 一些扣细节的面试官可能会给你一些配置, 问你我的配置会形成多少个 chunk)

在多数情况下, 一个 chunk 会产生一个 bundle, 但是也有例外

那什么情况下 chunk 和 bundle 不是一一对应的关系呢？
eg: devtool 配置开启了 source-map
在这种情况下, entry 和 output 的配置都没有改变, 所以 chunk 是没有变化的
但是由于开启了 source-map, 多了个 .map 文件, 会产生一个 chunk 对应两个 bundle 的情况

chunk 是过程中代码块, bundle 是打包结果输出的代码块, chunk 在构建完成就呈现为 bundle

4. Split Chunk

把不同的 Chunk 进行分割

5. 这段配置会产生几个 chunk

## 4. Plugin 和 Loader 分别是什么 ? 怎么工作的 ?

1. Loader

模块转换器, 将非 js 模块转化为 webpack 能够识别的 js 模块.

本质上, webpack loader 将所有类型的文件, 转换为应用程序的**依赖图**(可以直接引用的模块).

2. Plugin

扩展插件, 运行在 webpack 打包的各个阶段, 它是以事件的形式进行工作的

在 webpack 打包的各个阶段, 都会广播出对应的事件, 插件会去监听对应的事件(ps: 这也是 webpack plugin 这么火的原因, 不需要 webpack 去维护, 可以让整个社区来壮大 webpack, 它已经把打包过程中各个事件都抛出来了, 易于扩展)

3. Compiler

Compiler 对象, 包含了 webpack 环境的所有配置, 包括 options, loader, plugins, 在 webpack 启动的时候会去实例化, 它在全局是唯一的, 可以把它理解为 webpack 的实例

4. Compliation

包含了当前的模块资源, 编译生成资源

webpack 在开发模式下运行的时候, 每当检测到一个文件变化, 就会创建一个新的 Compliation, 所以 Compliation 在打包过程中是会产生很多个的

## 4. 你能简单地描述下 webpack 的打包过程吗？

如果你能描述出来, 后面有代码等着你了, 如果你不能描述出来, 那 webpack 就到这里了

1. 初始化参数: shell + webpack.config.js
2. 开始编译: 产生一个 Compiler 对象, 加载所有的配置, 开始执行编译
3. 确定入口: 根据 entry 配置, 找到所有的入口文件
4. 编译模块: 从入口文件开始, 调用所有的 loader,再去递归找依赖, 如果是多个入口, 就会有几条线路, 去搜索各种依赖文件
5. 完成模块编译: 得到每个模块被翻译后的内容以及他们之间的依赖关系(依赖图: 因为它可能会有很多分叉, 叫图更为合适)
6. 输出资源: 根据依赖关系, 组装成一个个包含多个模块的 chunk
7. 输出完成: 根据配置, 确定要输出的文件名和文件路径

## 5. 实现一个简单的 webpack

loader 和 plugin 是锦上添花的内容, 这里实现 webpack 核心的内容

1. ESModule

### 概览

1. 找到一个入口
2. 解析入口文件, 提取依赖关系
3. 解析入口文件依赖的依赖, 递归得创建文件间的依赖图, 描述所有文件的依赖关系
4. 把所有文件打包成一个文件

```js

```
