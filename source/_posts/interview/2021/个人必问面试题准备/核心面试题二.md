# 核心面试题二

## 有做过前端性能加载优化的工作吗？都做过哪些努力

千万不能特别笼统地一上来就说, 我做了一些分包, 我做了一些 js 体积啥啥啥的, 这么说其实是非常没有框架, 没有逻辑的

最重要的是: 做性能优化的目的是什么?

一定要是出现了什么问题才会去做优化, 不然系统运行的好好的为什么要做优化

要说, 我们的系统哪一个指标, 影响了什么业务, 然后我们打算做哪个方面的努力, 去优化这个指标

然后面试官说你们项目比较重视哪些指标

### 那前端比较关心的几个指标:

1. 首屏时间(白屏时间)
2. 首次可交付时间
3. 首次有意义内容渲染时间(比如百度的那个搜索框)

页面性能检测: https://developers/google.com/speed/pagespeed/insights/

polyfill: https://polyfill.io/v3/url-builder/

### 能够做的:

1. 只请求当前需要的资源

异步加载, 懒加载, polyfill(不一定浏览器都能跟上 es6 等的脚步, 比如 Array.flat, 做一些对低版本浏览器的适配)

但是通常 polyfill 要去对各种浏览器做适配, 所以包也会比较大, 那通常对它做优化的话就是不要用 webpack 把它打包进包里去, 使用一个 CDN 链接
打开上面的链接, https://polyfill.io/v3/url-builder/, 使用这个 CDN 链接, 它会识别当前的浏览器, 是高版本的浏览器还是低版本浏览器, 会根据当前浏览器的情况, 针对引入, 就相当于这个链接就已经实现了按需加载, 根本不需要我们自己做一些 webpack 的配置

国内的话, 阿里也做了这样的一个服务, 可以使用阿里的服务, 这个是国外的

2. 缩减资源体积

打包压缩 webpack 4
gzip
图片格式的优化(比如要了解一张图片是否需要这么高的分辨率), 压缩图片(推荐这个网站: tinypng ), 根据不同分辨率展示不同分辨率的图片(webp, 如何判断浏览器支持 webp)
尽量控制 cookie 大小(对于一个请求都会带上一些同域名全部的 cookie)

3. 时序优化

js promise.all, 对于这些没有关联的请求, 可以并行发请求
ssr: 不是把文件放在 CDN 上让用户去拉 CDN 的文件, 而是直接由服务器直出, 这样也有个好处, 就是可以做缓存(虽然说千人千面, 但是有些用户的资源是相似的, 这样第二批用户进来可以直接拉缓存), 还有就是 SEO
prefetch, prerender, preload

```js
// 对一些常用的请求网站, 提前做一个 DNS 的域解析, 平时来说可能是等真正发请求的时候才会去进行 DNS 解析, 但是可以通过这样 link 提前去做解析, 这样需要发送请求的时候就可以立即发送
<link rel="dns-prefetch" href="xxx1.com" />
<link rel="dns-prefetch" href="xxx2.com" />
// 预连接
<link rel="preconnect" href="xxx2.com" />
// 一些比较重要的元素, 可以放在这里预加载一下
<link rel="preload" as="image" href="https://aaa.com/p.png" />
```

4. 合理利用缓存

CDN(CDN 预热, CDN 刷新)
CDN 预热: 在用户还没有请求的情况下, CDN 服务商提前把源站的内容拉取放在 CDN 上
CDN 刷新: 在源站内容更新的情况下, 强制让 CDN 去拉取 源站更新的内容

CDN 预热的好处: 如果没有做 CDN 预热, 对于一些请求比较大的内容, 可能突然大量的流量涌入, 而这时 CDN 上没有任何内容, 就会把请求全部都打到源站上, 源站通常是我们内部的服务器, 可能会把源站打挂

还有需要知道的一个点就是, 通常 CDN 的域名跟网站的域名是不一样的, 比如 douyin.com, cdn 可能为 cdn-douyin.com
这是为什么呢?
因为 cookie 会在同源的请求去携带, 可能 cookie 中有大量的业务的 cookie, 其实在 CDN 上是没有必要去携带的, 所以为了不必要的消耗, 通常 CDN 都会用不同的域名

### 如果一段 js 运行时间比较长, 如何去得知是哪一个函数运行时间比较长？

可以使用装饰器来对函数来进行一个运行时间的计算

```js
function meature(target, name, descriptor) {
  const oldValue = descriptor.value;
  // 通常耗时比较大的都是异步的函数
  descriptor.value = async function () {
    // 记录开始时间
    console.time(name);
    // 执行
    const res = await oldValue.apply(this, arguments);
    // 结束时间
    console.timeEnd(name);
    return res;
  };
  return descriptor;
}
```

### 面试官经常喜欢出一些场景题, 来考察候选人

1. 阿里云 oos 支持通过链接后面拼接参数来做图片的格式转换, 尝试写一下, 把任意格式转换为 webp, 需要注意什么?

想了解的其实不是候选人怎么拼接参数, 而是要考察候选人边界问题, 因为 webp 其实不是所有浏览器都适配的, 所以候选人怎么去适配, 其实是考察候选人对各种边界条件的判断, 以及对浏览器的兼容条件？

只要有一个点没考虑全, 那就是扣分的, 对于浏览器的边界条件是非常严格的, 只要有一个点没考虑全它就有可能报错

可以使用 Can I Use 这个网站来查看浏览器的支持情况

所以:

1. 检测浏览器的 webp 支持情况

```js
// 创建一个 canvas 元素, 因为它可以很方便的把图片转为 base64 的形式
// 转为 base64, 如果这个 url 是以 data:image/webp 格式开头的, 就表明浏览器是支持 webp 格式的
function checkWebp() {
  try {
    return (
      document
        .createElement("canvas")
        .toDataURL("image/webp")
        .indexOf("data:image/webp") === 0
    );
  } catch (e) {
    return false;
  }
}

// 是否支持 Webp
const isSupportWebp = checkWebp();
```

```js
// 考察候选人的边界能力
function getWebpImageUrl(url) {
  // 一定要把错误扼杀在摇篮里, 在开始就要进行检测
  if (!url) {
    // 抛错, 或者     return url;
    throw new Error("url不能为空");
  }

  // 检测是否为 base64 的图片
  if(url.startsWith(data:)) {
      return url;
  }

// 如果不支持 Webp, 也 return 回去
  if(!isSupportWebp) {
      return url;
  }

// 再去对 url 拼接阿里云的参数
  return url + '?x-oss-process....';

}
```

2. 如果你的页面上有巨量的图片要展示, 那除了懒加载的形式, 还有什么形式可以来限制下同时加载的数量?(代码题, 写代码来实现并发的控制)
