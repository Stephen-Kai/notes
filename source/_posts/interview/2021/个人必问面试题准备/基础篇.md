# 个人必问面试题基础

## 1: 对原型和原型链的理解, js 如何实现继承?

简单地理解，继承就是一个对象可以访问另外一个对象中的属性和方法，比如我有一个 B 对象，该对象继承了 A 对象，那么 B 对象便可以直接访问 A 对象中的属性和方法。

不同的语言实现继承的方式是不同的，其中最典型的两种方式是基于类的设计和基于原型继承的设计。

JavaScript 仅仅在对象中引入了一个原型的属性，就实现了语言的继承机制，基于原型的继承省去了很多基于类继承时的繁文缛节，简洁而优美。

JavaScript 的每个对象都包含了一个隐藏属性 **proto** ，我们就把该隐藏属性 **proto** 称之为该对象的原型 (prototype)，**proto** 指向了内存中的另外一个对象，我们就把 **proto** 指向的对象称为该对象的原型对象，那么该对象就可以直接访问其原型对象的方法或者属性。

举例子: A -> B -> C (A 可以访问 C 的属性, 看上去就像是 A 自身的属性一样)

把这个查找属性的路径称为原型链，它像一个链条一样，将几个原型链接了起来

不要将原型链接和作用域链搞混淆了，作用域链是沿着函数的作用域一级一级来查找变量的，而原型链是沿着对象的原型一级一级来查找属性的，虽然它们的实现方式是类似的，但是它们的用途是不同的

继承就是一个对象可以访问另外一个对象中的属性和方法，在 JavaScript 中，我们通过原型和原型链的方式来实现了继承特性

通常隐藏属性是不能使用 JavaScript 来直接与之交互的。虽然现代浏览器都开了一个口子，让 JavaScript 可以访问隐藏属性 _proto_，但是在实际项目中，我们不应该直接通过 _proto_ 来访问或者修改该属性，其主要原因有两个：首先，这是隐藏属性，并不是标准定义的 ;其次，使用该属性会造成严重的性能问题。

那应该怎么去正确地设置对象的原型对象呢?

答案是使用构造函数来创建对象

举例子: var dog = new DogFactory('Dog','Black')

v8 做的事情:

```js
var dog = {}
dog.**proto** = DogFactory.prototype
DogFactory.call(dog,'Dog','Black')
```

首先，创建了一个空白对象 dog；然后，将 DogFactory 的 prototype 属性设置为 dog 的原型对象，这就是给 dog 对象设置原型对象的关键一步，我们后面来介绍；最后，再使用 dog 来调用 DogFactory，这时候 DogFactory 函数中的 this 就指向了对象 dog，然后在 DogFactory 函数中，利用 this 对对象 dog 执行属性填充操作，最终就创建了对象 dog。

每个函数对象中都有一个公开的 prototype 属性，当你将这个函数作为构造函数来创建一个新的对象时，新创建对象的原型对象就指向了该函数的 prototype 属性, 可以把公共的属性都放在 函数的 prototype 上

对象的原型对象都指向了 prototype，而 prototype 又包含了 公共的属性，这就是我们实现继承的正确方式

还有要注意的一点:

DogFactory._proto_ 和 DogFactory.prototype 没有直接关系

DogFactory 是 Function 构造函数的一个实例，所以 DogFactory.**proto** === Function.prototype

DogFactory.prototype 是调用 Object 构造函数的一个实例，所以 DogFactory.prototype.**proto** === Object.prototype

```
function f() {}
console.log(f.__proto__ === Function.prototype); // true
console.log(f.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__ === null); // true
```

以上就是我对原型链的理解, 谢谢 ～

实现继承的几种方式:

## 2: 对作用域和作用域链的理解?

作用域链就是将一个个作用域串起来，实现变量查找的路径。讨论作用域链，实际就是在讨论按照什么路径查找变量的问题。

作用域就是存放变量和函数的地方，全局环境有全局作用域，全局作用域中存放了全局变量和全局函数。每个函数也有自己的作用域，函数作用域中存放了函数中定义的变量。

全局作用域是在 V8 启动过程中就创建了，且一直保存在内存中不会被销毁的，直至 V8 退出。 而函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就随之被销毁掉了。

首先当 V8 启动时，会创建全局作用域，全局作用域中包括了 this、window 等变量，还有一些全局的 Web API 接口，V8 会先编译顶层代码，在编译过程中会将顶层定义的变量和声明的函数都添加到全局作用域中，全局作用域创建完成之后，V8 便进入了执行状态。

当 V8 执行 bar 函数的时候，同样需要经历两个阶段：编译和执行。

V8 会为 bar 函数创建函数作用域，然后进入了 bar 函数的执行阶段。在 bar 函数中，只是简单地调用 foo 函数，因此 V8 又开始执行 foo 函数了， 同样，在编译 foo 函数的过程中，会创建 foo 函数的作用域。

好了，这时候我们就有了三个作用域了，分别是全局作用域、bar 的函数作用域、foo 的函数作用域。

由于 bar 和 foo 函数的外部代码都是全局代码，所以无论你是在 bar 函数中查找变量，还是在 foo 函数中查找变量，其查找顺序都是按照当前函数作用域–> 全局作用域这个路径来的。

因为 JavaScript 是基于词法作用域的，根据函数在代码中的位置来确定的，在声明函数时就确定好的了。

以上就是我对作用域链的理解, 谢谢 ～

## 3. V8 的 JIT 即时编译技术？

通常高级语言要被机器识别，有两种方式

1. 编译执行(C), 把文件先编译成二进制文件, 后续执行都使用这个二进制文件, 启动慢, 执行快
2. 解析执行(JS), 每次执行都会先解析成字节码, 再执行, 启动快, 执行会更慢

但是 V8 并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段

V8 接收到 JS 源代码, 对于 V8 来说就是一堆字符串, 并不能直接理解这段字符串的含义，它需要结构化这段字符串, 转化成 V8 理解的结构, 也就是抽象语法树 (AST), 同时生成相关的作用域

(Babel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码)

有了 AST 和作用域之后，接下来就可以生成字节码, 解释器可以直接解释执行字节码

V8 同时也会进行监控, 如果一段代码执行了很多次, 标记为热点代码, 将这段字节码丢给优化编译器, 编译为二进制代码, 再执行到这段代码时，那么 V8 会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升

一旦在执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时候优化编译器就需要执行反优化操作，经过反优化的代码，下次执行时就会回退到解释器解释执行

那这种又 编译执行 和 解析执行的技术就是 JIT 即时编译技术

## 4. 输入 url 到页面渲染完成发生了什么？

HTML 和 CSS 和 JS 经过一系列处理然后输出为屏幕上的像素等等

#### 获取资源

1. 当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL
2. 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。
3. 如果判断输入内容符合 URL 规则，比如输入的是 time.geekbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 https://time.geekbang.org。
4. 浏览器刚会加载，标签页上的图标便进入了加载状态(需要等待提交文档阶段，页面内容才会被替换)
5. 进入了页面资源请求过程, 浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程
6. 查找本地缓存, 否则进入网络请求流程, 进行 DNS 解析(浏览器缓存 -> 系统缓存 -> 路由缓存 -> DNS 解析)
7. 服务器接收到请求信息后，会根据请求信息生成响应数据
8. Content-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器服务器返回的响应体数据是什么类型, 如果是 text/html, 返回的数据是 HTML 格式, 准备渲染进程
9. Chrome 会为每个页面分配一个渲染进程(除非同站点, 即根域名 + 协议相同)
10. 浏览器进程发出提交文档的消息，渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”, 接收到数据后就会开始执行渲染流水线

#### 渲染流水线步骤

1. 构建 DOM 树
2. 样式计算
3. 布局阶段
4. 分层
5. 绘制
6. 分块
7. 光栅化和合成

#### 执行渲染流水线

1. 浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树

2. 当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets(也会把值转化为渲染引擎容易理解的计算值, 比如 bold 转 700)

3. 计算出 DOM 树中每个节点的具体样式(CSS 的继承规则和层叠规则)

4. 布局阶段(计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局)

创建布局树, 在显示之前，我们还要额外地构建一棵只包含可见元素布局树
布局计算, 把布局运算的结果重新写回布局树中

5. 渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树(一些复杂的 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等), 渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面

并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层

6. 图层绘制, 会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表, 所以在图层绘制阶段，输出的内容就是这些待绘制列表

7. 栅格化（raster）操作

当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程

但是有些情况下, 有的图层可以很大, 比如有的页面你使用滚动条要滚动好久才能滚动到底部, 所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要, 基于这个原因，合成线程会将图层划分为图块（tile）

合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图

通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中

8. 合成和显示

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程

浏览器进程接受到了绘制图块的命令, 将其页面内容绘制到内存中，最后再将内存显示在屏幕上

结合上图，一个完整的渲染流程大致可总结为如下：

渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。
渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。
创建布局树，并计算元素的布局信息。
对布局树进行分层，并生成分层树。
为每个图层生成绘制列表，并将其提交到合成线程。
合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。
合成线程发送绘制图块命令 DrawQuad 给浏览器进程。
浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。

#### 重排

改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排

#### 重绘

更新元素的绘制属性, 相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些

#### 直接合成阶段

使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作, 相对于重绘和重排，合成能大大提升绘制效率

## 5. 垃圾回收机制？

首先讲 js 的垃圾回收机制, 再扩展到 Chrome 的垃圾回收.

#### js 的垃圾回收:

1. 标记清除
2. 引用计数

#### Chrome 的垃圾回收:

V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象

副垃圾回收器，主要负责新生代的垃圾回收。

主垃圾回收器，主要负责老生代的垃圾回收。

不论什么类型的垃圾回收器，它们都有一套共同的执行流程:

1. 第一步是标记空间中活动对象和非活动对象
2. 第二步是回收非活动对象所占据的内存
3. 第三步是做内存整理(内存碎片)

###### 副垃圾回收器:

两个区域: 对象区域和空闲区域
新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作
在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。
完成复制后，对象区域与空闲区域进行角色翻转

对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中

###### 主垃圾回收器:

老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。

采用标记 - 整理
标记过程阶段: 从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。
整理阶段: 让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

###### 全停顿

问题: 垃圾回收是运行在主线程之上的，待垃圾回收完毕后再恢复脚本执行, 占用主线程时间过久的话, 交互, 造成页面的卡顿现象
解决: 使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务, 穿插在其他的 JavaScript 任务中间执行

#### 优化点

如果在 A 函数中循环调用很多次 B 函数，如果 B 函数一直有像 new Array 这样的操作，其实是可以在 A 函数中创建好，传入 B 函数中，这样就不用在 B 函数中频繁地分配内存，减少垃圾回收的频率

## 6. js 的类型系统?

提供来 isPrimitive 函数, 执行流程如下

1. 调用对象的 valueOf 方法，如果返回的是基础类型，则使用该返回值
2. 如果不是，则调用 toString() 方法, 如果返回的是基础类型，则使用该返回值
3. 如果都不是，则会报错

## 7. XSS 攻击 和 CSRF 攻击?

#### XSS

跨站脚本攻击

1. 窃取 Cookie 信息(document.cookie)
2. 监听用户行为(addEventListener)
3. 在页面内生成浮窗广告, 影响用户体验

存储型 XSS 攻击(将恶意 JavaScript 代码提交到网站的数据库中)
反射型 XSS 攻击(将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端, 比如在 url 上添加 script 脚本)
基于 DOM 的 XSS 攻击(通过各种手段将恶意脚本注入用户的页面中, 在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据)

如何阻止?

1. 客户端对输入内容进行过滤, 服务器对输入脚本进行过滤或转码
2. 充分利用 CSP(内容安全策略, 设置响应头, 禁止向第三方域提交数据等等)
3. 使用 HttpOnly 属性

#### CSRF

利用用户的登录态, 通过第三方站点来做坏事

1. 自动发起 get 请求(img src 加转账请求)
2. 构建隐藏表单, 自动提交
3. 引诱用户点击链接, 发起请求

跟 XSS 不同, CSRF 主要是针对浏览器的漏洞和用户的登录态来实施攻击

条件:

1. 目标站点有 CSRF 漏洞
2. 用户登录过目标站点，并且保持登录态
3. 需要用户打开第三方站点

解决：

1. cookie 的 same-site 属性
2. 服务端要验证请求的来源, 比如说 referer 和 origin 和 host
3. 使用 CSRF Token

## 8. HTTP1 & HTTP1.1 & HTTP2 & HTTP3 的区别?

#### HTTP1

HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接

#### HTTP1.1

改进持久连接: 在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。

优点:

1. 有效减少 TCP 建立连接和断开连接的次数
2. 减少了服务器额外的负担，并提升整体 HTTP 的请求时长

浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接(使用 CDN 的实现域名分片机制)

缺点:

1. 需要等待前面的请求返回, TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求
2. 同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽, 多条 TCP 连接之间又不能协商让哪些关键资源优先下载

#### HTTP2

多路复用: 通过引入二进制分帧层，就实现了 HTTP 的多路复用技术, 数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器

1. 只使用一个 TCP 长连接来传输数据, 避免了多个 TCP 连接竞争带宽所带来的问题
2. 实现资源的并行请求, 不需要等待其他请求的完成, 解决对头阻塞的问题, 主要是因为每个请求都有对应的 ID, 服务器端可以根据喜好来决定优先返回哪些内容

HTTP/2 其他特性:

1. 可以设置请求的优先级
2. 服务器推送
3. 头部压缩

#### HTTP3

TCP 协议存在队头阻塞和建立连接延迟等缺点, 但是由于很多原因比如传输的中间设备僵化等, 要去修改 TCP 协议是非常困难的

基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，称为 QUIC 协议

UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性

QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。

由于 QUIC 是基于 UDP 的，不需要像 TCP 的三次握手过程, 大大提升首次打开页面的速度

挑战:

1. 中间设备僵化的问题。对 UDP 的优化程度远远低于 TCP
2. 服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持

## 9. 如何理解闭包?

举个例子:
有一个函数 A，函数 A 中声明了一个变量 name, 一个函数 B, 函数 B 中使用到了 外部函数 A 的 name 变量, 并且函数 A 把 函数 B return 出去了, 在函数 A 调用时使用了一个变量来接收 return 出去的函数 B, 那这个时候就产生了闭包。

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 A，那么这些变量的集合比如刚刚的 name 就称为 A 函数的闭包。

通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

使用闭包的时候，你要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量

闭包的缺点:

1. 像刚刚提到的, 如果引用的是全局变量, 如果这个闭包以后不再使用, 会造成内存泄露

闭包的使用场景:

1. 在函数外读取函数内部的变量
2. 让局部变量的值能够被保存下来
3. 将模块的公有属性和方法暴露出来

那以上就是我对闭包的理解, 谢谢 ～

## 10. js 中的快属性和慢属性?

从一个 obj 例子开始说起, 排序属性和常规属性，一个对象中最多存放 10 个属性,快属性, 优化点：尽量少使用 delete， 用了 delete bar.property2 之后，就没有快属性了，我们查找属性的速度就会变慢

## TCP 和 UDP 协议, 还有三次握手过程?
