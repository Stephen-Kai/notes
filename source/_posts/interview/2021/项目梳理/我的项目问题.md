# 项目

https://umijs.org/zh-CN/docs/getting-started
https://ahooks.js.org/zh-CN/

项目中做了哪些优化
遇到了哪些问题
做了哪些封装等等
你为什么这么做
这么做的意义是什么
是为了解决什么问题
你用了之后的效果

气势吧
就是不能被他震住
要有理有据
然后就是沟通一定要清晰

目前还未开放公测，接入了一些 KA 用户, 李宁，美宜佳，枫叶，wonderlab

SCQA 模型: 介绍背景, 指出冲突, 提出疑问, 分析解答

# 项目选型

## 为什么选择 umi ?

1. 技术收敛
2. 对开发者很友好
3. 大量项目验证
4.

# 项目中做了哪些优化

## 首屏加载

1. 开启了 umi 的 dynamicImport 按需加载配置, 把构建产物进行拆分，在需要的时候下载额外的 JS 再执行时候才会请求, 原本只生成一个 js 和一个 css, 对用户来说初次打开网站会比较慢

按需加载前一个 umi.js 文件有 5.6M, 压缩之后也有 1.7 M, umi.css 文件 1.1M, 压缩后 224KB

开启按需加载后, umi.js 文件是 3.3 MB, 压缩后是 1.1M

2. 拆包优化

拆包优化后, 拆成了四个包, libs, common, vendors 还有主包 umi.js

umi.js: 1.3MB 压缩后只有 452KB  
libs: 824KB 压缩后只有 237KB
common: 441KB 压缩后只有 108KB
vendors: 1.2MB 压缩后只有 387KB

- 优化前: umi 主包, 加载 1.3s
- 优化后: vendor.js(371M), lib.js(223k), umi.js(367k), 加载 0.26s
- 清理无用代码, 删除 70 多个冗余文件

如何进行拆包优化:

umi 提供了一个 chainWebpack 配置, 供开发者修改 webpack 配置, 其中有一个 optimization 优化配置, 在 splitChunks 中去配置

## 用户体验

1. 页面加一层 loading, 请求时展示 loading 态, 缓解用户等待情绪
2. 每次用户操作都会即使给反馈, 比如说点击按钮, 展示 loading 态, 同时加上
3. 一些表单加上了骨架屏, 因为表单是有统一规范, 大小都类似, 所以我实现了一个 Skeleton 组件, 在需要的地方进行包裹
4. 还有防抖, 我开发了素材选择组件, 这个组件中左边是分组, 右边是列表还有搜索框, 那不排除有些用户可能会频繁地点击分组, 所以也有给点击分组加上防抖
5. 还有一些固定的数据可以进行缓存, 比如我有开发一个标签的选择组件, 是用于素材审核不通过的时候选取, 数据有点大, 后端可能是考虑一次性拉取数据会有问题, 所以拆成了两个接口, 点击前一个用 id 来查询它的子标签, 那像这种数据其实是比较固定的, 那就可以用一个对象或者 map 去缓存, 调用接口前先判断, 获取到数据进行保存
6. 还有尽可能减少请求数量吧, 比如我有做过一个优化需求, 像有些比较敏感的图片是要做一个私有读写, 也就是获取到的图片是要调用另外一个接口去获取临时展示的图片, 然后那个原本的开发做的是每一个图片都去调用一次这样的接口, 那偶尔就会出现接口错误的, 但是那个接口其实是可以批量处理的, 所以的话我就把图片先收集起来一次批量处理, 那后面也没出现这样的接口错误的情况
7. 那可能还会有一些 dom, 比如说有一些 dom 经常切换显示隐藏这样, 那其实是可以使用 css 来控制, 这一点其实是 react diff 有关, react diff 算法是同层比对的
8. 尽量使用 className 设置样式, 特别是对一些需要设置很多样式的, 或者可以复用的样式
9. 一些静态资源部署在了 cdn 上, cdn 可能存在缓存的问题, 有时候重新提交急用的话就需要换个名字, cdn 在广州

## 代码优化

1. 请求封装 Service, 统一管理

改造之前是这样的
所有的 api 都写在了一个文件中, 我记得那个文件有 1000 多行了, 太庞大了, 没有根据业务去拆开, 难以维护
后来经常会遇到的问题就是
mr 时会有冲突, 很多 api 其实有相同的前缀但是没有统一管理

那针对这个问题进行改造, 基于 umi-request 封装请求 Service, 统一编写规范, prefix 要统一管理, 把 api 配置整理到各个业务的 service 目录，规避合并代码时冲突的问题

在一个文件中统一放置 service 的 prefix, 如果有相同的 prefix 可复用

实现一个 Service 类, constructor 中接收一个 prefix 来进行初始化, 实现一个 callService 的方法, 输入为 apiName, 请求参数 params 等, 使用 umi-request 提供的 extend 方法来进行调用

那这样就解决上面的问题, 但是 request 方法是统一封装的一个方法, 考虑到后续业务可能需要自定义 request, 来实现更加灵活的请求拦截等需求, 便在 constructor 中进行接收 request, 这是一个可选参数, 如果传入则使用传入的 request, 如果没有则使用默认的

在改造过程中，也有根据接口协议来对一些错误添加默认提示语等等, 也有对接口请求和返回值统一做鉴权处理, commonRequest.interceptors.request, commonRequest.interceptors.response

那这就是 Service 改造流程, 代码的可维护性和可读性，灵活性都有提高, 也没有再发生这种由于 api 文件的冲突了

再考虑到这个其实是一个通用的功能模块, 也有把这个作为一个 npm 包来进行, 这句话我还是不提了吧

2. 数据请求加防抖, 加缓存

# 项目难点

# 项目亮点

## 最近在做的事情(素材选择器优化 && ScrollView 封装)

MaterialSelector:

思路: 见组件封装 MaterialSelector

ScrollView: 一个触底自动触发加载的计算方法

思路: 见组件封装 ScrollView

## 封装 FormItem & FormSection 挂在 FormContainer 下

思路: 见组件封装 FormContainer

## 列表筛选项回显处理

## 
