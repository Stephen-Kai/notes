# 项目

https://umijs.org/zh-CN/docs/getting-started
https://ahooks.js.org/zh-CN/

项目中做了哪些优化
遇到了哪些问题
做了哪些封装等等
你为什么这么做
这么做的意义是什么
是为了解决什么问题
你用了之后的效果

气势吧
就是不能被他震住
要有理有据
然后就是沟通一定要清晰

# 项目选型

## 为什么选择 umi ?

1. 技术收敛
2. 对开发者很友好
3. 大量项目验证
4.

# 项目中做了哪些优化

## 首屏加载

1. 开启了 umi 的 dynamicImport 按需加载配置, 把构建产物进行拆分，在需要的时候下载额外的 JS 再执行时候才会请求, 原本只生成一个 js 和一个 css, 对用户来说初次打开网站会比较慢

按需加载前一个 umi.js 文件有 5.6M, 压缩之后也有 1.7 M, umi.css 文件 1.1M, 压缩后 224KB

开启按需加载后, umi.js 文件是 3.3 MB, 压缩后是 1.1M

2. 拆包优化

拆包优化后, 拆成了四个包, libs, common, vendors 还有主包 umi.js

umi.js: 1.3MB 压缩后只有 452KB  
libs: 824KB 压缩后只有 237KB
common: 441KB 压缩后只有 108KB
vendors: 1.2MB 压缩后只有 387KB

- 优化前: umi 主包, 加载 1.3s
- 优化后: vendor.js(371M), lib.js(223k), umi.js(367k), 加载 0.26s
- 清理无用代码, 删除 70 多个冗余文件

## 用户体验

1. 页面加一层 loading, 请求时展示 loading 态, 缓解用户等待情绪
2. 每次用户操作都会即使给反馈, 比如说点击按钮, 展示 loading 态, 同时加上
3. 一些表单加上了骨架屏, 因为表单是有统一规范, 大小都类似, 所以我是实现了一个 Skeleton 组件, 在需要的地方进行包裹
4. 还有防抖, 我开发了素材选择组件, 这个组件中左边是分组, 右边是列表还有搜索框, 那不排除有些用户可能会频繁地点击分组, 所以也有给分组加上防抖
5. 还有一些固定的数据可以进行缓存, 比如我有开发一个标签的选择组件, 是用于素材审核不通过的时候选取, 数据有点大, 后端可能是考虑一次性拉取数据会有问题, 所以拆成了两个接口, 点击前一个用 id 来查询它的子标签, 那像这种数据其实是比较固定的, 那就可以用一个对象或者 map 去缓存, 调用接口前先判断, 获取到数据进行保存
6. 还有尽可能减少请求数量吧, 比如我有做过一个优化需求, 像有些比较敏感的图片是要做一个私有读写, 也就是获取到的图片是要调用另外一个接口去获取临时展示的图片, 然后那个原本的开发做的是每一个图片都去调用一次这样的接口, 那偶尔就会出现接口错误的, 但是那个接口其实是可以批量处理的, 所以的话我就把图片先收集起来一次批量处理, 那后面也没出现这样的接口错误的情况
7. 那可能还会有一些 dom, 比如说有一些 dom 经常切换显示隐藏这样, 那其实是可以使用 css 来控制, 这一点其实是 react diff 有关, react diff 算法是同层比对的
8. 尽量使用 className 设置样式, 特别是对一些需要设置很多样式的, 或者可以复用的样式
9. 一些静态资源部署在了 cdn 上, cdn 可能存在缓存的问题, 有时候重新提交急用的话就需要换个名字, cdn 在广州

## 代码优化

1. 请求封装 Service, 统一管理
2. 数据请求加防抖, 加缓存

# 项目难点

# 项目亮点

## 最近在做的事情(素材选择器优化 && ScrollView 封装)

素材选择器优化, 封装 ScrollView.

改造点：见 2021 / 5.19 文件

ScrollView: 一个触底自动触发加载的计算方法

思路: 见组件封装 ScrollView

## 封装 FormItem & FormSection 挂在 FormContainer 下

https://www.react-hook-form.com/zh/v6/api#Controller
https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView

1. 已有功能: 基础表单受控组件 Input 等存在
2. WebApi 提供了 scrollIntoView 可以滚动到指定元素位置

功能: 基于 react-hook-form 封装，实现提交表单，自动跳转(scrollInToView) 到错误的表单项目
实现思路:

首先就是初始化的时候需要收集每个表单的 ref, 当提交的时候, react-hook-form 会抛出错误信息 errors, 以键值对的形式保存着校验不通过的表单的 name 和 错误信息, 那组件监听到错误信息, 需要找到最顶部的错误表单

1. 实现一个 FormContainer, 使用 useReducer 存储各表单的 ref
2. 实现一个 FormItem, 包裹表单, 初始化时 dispatch ref 给 FormContainer
3. 封装 useScrollToFirstError Hook, 输入是当前存储的各表单 ref, 还有 react-hook-form 抛出的 errors 对象, 功能是监听到错误信息时, 处理有错误时滚动到第一个表单
4. useScrollToFirstError Hook 首先收集错误表单 name 数组, 遍历这个数组, 从 ref state 中拿到对应的 ref, 找到距离顶部最近的表单 ref, 使用 scrollIntoView 滚动到具体的表单位置

##
