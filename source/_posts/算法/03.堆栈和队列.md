# 堆栈和队列(Stack & Queue)

## 特点

Stack: 先进后出, 后出先出
Queue: 先进先出

实现可以是数组, 也可以是链表

## 实战

### leetcode - 20. 大中小括号, 判断这个字符串是否合法

#### 比较推荐的做法

a. 左括号 => push
b. 右括号 => pop, 查看栈顶是否有匹配的括号
c. 如果全部都走完了, 也就是全部匹配的话, 堆栈本身要是空的

```js
function isValid(s) {
  // 保存左括号
  const stack = [];
  // 字典记录左右括号对应关系
  const map = {
    "(": ")",
    "[": "]",
    "{": "}",
  };
  for (let i = 0; i < s.length; i++) {
    // 判断是否有这个 key, 如果有, 进行 push, 如果没有, pop 弹出比对
    if (map.has[s[i]]) {
      stack.push(s[i]);
    } else {
      if (stack.length !== 0 && s[i] !== map.get(stack.pop())) {
        return false;
      }
    }
  }
  return stack.length === 0;
}
```

#### 别的做法

while 循环使用 replace('{}', '').replace('[]', '').replace('()', '');

不是很推荐, 虽然看着清楚明了, 但是时间复杂度不好判断

### leetcode - 232, 225 只用堆栈实现队列的效果 / 只用队列实现堆栈的效果

#### 只用堆栈实现队列的效果

先进后出 -> 先进先出

push / pop / peek

用两个堆栈结构, 一个为 Input, 保存输入的内容, 一个为 Output, 保存输出的内容

首先元素 push, 往输入栈里面放

如果元素 pop, 判断 Output 中有没有内容, 如果有, pop, 如果没有, 把 Input 的元素都放入到 Output 中, pop

一定要有两个栈, 倒腾下顺序

```js

```

#### 只用队列实现堆栈的效果

先进先出 -> 先进后出

# 优先队列

正常入, 按照优先级出

## 实现机制

1. 堆来实现
2. 二叉搜索树

## 科普

1. 最小堆, Mini Heap, 父节点是最小的
2. 大顶堆, Max Heap, 父节点是最大的

# 实战

## leetcode - 703 返回数据流中的第 K 大元素

如果是记录最大值, 进来一个元素, 就跟 max 比对

推断出来: 保存前 K 个最大的值, 保存值的数组排序, 每进来一个值, 把最小的淘汰掉

1: K, Max => sorted => NKlogK
2: 优先队列(小顶堆 O(nlog2K))

遍历, 如果队列中的个数小于 K, 直接 push,
否则, 取出堆顶元素, 如果小于该遍历元素, 剔掉堆顶元素, 加入该元素并进行排序, 到最后, 把堆顶元素 return 即可

```js

```

## leetcode - 239 返回滑动窗口中的最大值

1. 大顶堆, 堆顶元素为最大值, 维护 Heap, 结果就是堆顶元素(O(NlogK))
2. 双端队列(O(N))

```js

```
