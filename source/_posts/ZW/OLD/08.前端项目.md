# 前端项目

学习平时项目中会遇到什么问题, 如何去处理

## 开始

1. 安装

`npm init && npm i express`

2. 安装一个模块, 使我们不用每次服务器修改都重新启动, 下次跑的时候就直接 `nodemon server.js` 即可

`sudo npm i nodemon -g`

3. 安装中间件

`npm i body-parser`

4. 安装 `serve` 模块, 本地可开一个服务器

`sudo npm i serve -g`

5. 在 `index.html` 页面开个静态服务器

`serve`

6. 安装 `cors` 中间件, 解决同源策略问题, 配置 origin 和 credentials

`npm i cors`

7. 安装 `cookie-parser`, 设置 `cookie`

`npm i cookie-parser`

8.

## 知识点

1. 响应头中的 `Content-Type` 呢, 描述的就是 响应体 的类型, 浏览器接收到就会进行对应的处理
2. 如果请求某个资源, 比如 / , 服务器没有对对应路由进行处理, 状态码为 404
3. `get` 请求的参数可以在 `req.query` 中获取, `post` 请求的参数可以在 `req.body`
4. ?? & ||, || 呢是过滤为 false 的值, ?? 呢是过滤 undefined 和 null 的情况
5. 客户端可以给服务端发送很多类型的数据, 那也是依靠请求头中的 `Content-Type`来表示对应的类型, 主要针对的是 `post` 类型的请求, 像 body-parser 也是读取 `Content-Type` 中的类型来进行对应的处理
6. 设置了 `httpOnly`, 就不能通过 `document.cookie` 来进行访问的, 通常这种标识了用户身份信息的 cookie 会设置不能被读取, 它会在 http 请求中携带`Cookie` 请求头, 但是不会在 js 业务中去操作, 当然现在更多的是在请求头中设置一个标识, 那都是一样的, 都是用一个标识去标记
7.

## 中间件

像 express 呢或者其他的一些框架, 它只是一个框架, 可能不能对所有的内容进行一些覆盖, 所以提出了中间件的概念, 面向切面的 操作, 就是每一个请求之间其实是没有关联的, 请求 a 单独处理, 请求 b 单独处理, 每一个请求都是单独处理, 那就像切豆腐, 那能否在水平层面去对每一个请求进行处理, 那中间件就是这样的一个概念

在 express 中只要是一个函数就是一个合法的中间件, `app.use()` 来进行一个使用, 在每一个切面呢, 会接收到 请求对象, 响应对象, 以及 next

1. 中间件

[body-parser](https://www.npmjs.com/package/body-parser): 处理请求体的信息, express 框架没有处理 req.body 的内容, 读取 `Content-Type` 中的类型来进行对应的处理, 在切面上把对应的数据挂在 `req.body` 上, 那之后的 post 请求都可以在 `req.body` 上读取请求体

[cors](https://www.npmjs.com/package/cors): 统一加上响应头来实现跨域请求

[cookie-parser](https://www.npmjs.com/package/cookie-parser): 设置 cookie, 在切面上呢, 在 `req` & `res` 上加上了 cookie 的方法, session 就是这么一个概念, 在你登录鉴权之后呢生成这么一个 token, 原理就是在响应头中设置 `Set-Cookie` 字段信息, 可以设置过期时间, 是否 httpOnly 等

2.

## 项目想告诉我们的问题?

### 同源策略

需要在响应头中加上 `Access-Control-Allow-Origin`, 在 Node 中就可以使用 cors 的一个中间件来进行处理, 它会给我们通过的请求加上 `Access-Control-Allow-Origin` 这个头, 配置 `origin` 和 `credentials`

保证前后端跨域资源共享的两个响应头
配置了 `origin`, 那再请求的时候呢, 响应头中就会有 `Access-Control-Allow-Origin` 的响应头, 那浏览器接收到了就会进行对比, 就会知道这是一个合理可信的跨域请求
配置了 `credentials`, 响应头中就会有 `Access-Control-Allow-Credentials`, 表示是否可以将对请求的响应暴露给页面。返回 true 则可以，其他值均不可以, Credentials 必须在前后端都被配置, 才能使带 credentials 的 CORS 请求成功

[Access-Control-Allow-Credentials](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials)
[Access-Control-Allow-Origin](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin)

### cookie

使用了 `cookie-parser` 之后, 在响应头中已经设置了 `Set-Cookie` 响应头, token 也设置上了, 但是在 devtool cookie 中没有显示, 去掉 `httpOnly` 在页面获取也是 ''

解决:

`XMLHttpRequest.credentials = true` || fetch 请求中配置 `credentials` 为 `include`, 因为要能够携带像 cookie 这样的凭证需要 前后端 都进行设置, 具体如上

## 我遇到的问题?

1. 为什么我把 index.js 的内容拆成几个文件, 在 index.html 中引入 index.js 没有发送请求呢? 还遇到了语法错误, 大概跟 import 有关

解决方法:
在 web 应用中，script 标签的 type 属性设置为 module，这样浏览器就会把引入的脚本识别为 JS module,并且 import 的时候必须带上.js 的后缀名

```js
<script src="./index.js" type="module"></script>
```

参考文章: [浏览器中使用 ESModule](https://www.jianshu.com/p/f7db50cf956f)

哦，不是上面说的问题, 看到 `import {...} from './utils.js'`, 会发送一个/utils 的请求, 那是不是意味着只要有请求就会走到服务器, 那为什么 index.js 可以请求成功呢?

2.

## 知识点总结

1. `CORS`: 跨域是在前后端配合的过程中非常容易遇到的问题, 那具体的方式呢主要是服务端去增加 `Access-Control-Allow-Origin` & `Access-Control-Allow-Credentials`(如果要带 cookie 的话) 这样的几个 header, 或者把前后端都在一个同源策略下, 不过前后端分离之后很难把它们放在同一个同源策略下面, 这也是 `CORS` 这几个响应头起的一个作用, 通过约束服务端 api 允许的跨域请求来实现, 从而达到跨域资源共享的目的(举例子 cors)

2. `Content-Type`: `Request Header` 中的 `Content-Type` 主要是帮助服务端去明确客户端发送的参数具体的类型(举例子 body-parser) ; `Response Header` 中的 `Content-Type` 主要是响应体里的数据类型, 从而让浏览器进行正确的解析

3.

## 参考文献

[浏览器中使用 ESModule](https://www.jianshu.com/p/f7db50cf956f)
[Access-Control-Allow-Credentials](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials)
[Access-Control-Allow-Origin](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Access-Control-Allow-Origin)
[body-parser](https://www.npmjs.com/package/body-parser)
[cors](https://www.npmjs.com/package/cors)
[cookie-parser](https://www.npmjs.com/package/cookie-parser)
